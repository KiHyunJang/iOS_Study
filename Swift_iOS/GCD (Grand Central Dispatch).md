# GCD (Grand Central Dispatch)

iOS에서 GCD에는 DispatchQueue가 있다.  
DispathQueue를 알기위해서는  
직렬큐(Serial Queue)와 동시큐(Concurrent Queue), 동기(sync), 비동기(Async)를 알아야한다.  
  
## 직렬큐(Serial Queue)와 동시큐(Concurrent Queue)  
  
**Queue?**  
Queue는 FIFO로 먼저 들어간 것이 먼저 나온다 라는 특징을 가지고 있다.  
  
**그렇다면 Serial Queue와 Concurrent Queue란 무엇일까?**  
Serial Queue는 분산 처리시킨 작업을 하나의 다른 스레드에서 처리하는 큐  
Concurrent Queue는 분산 처리시킨 작업을 여러 개의 다른 스레드에서 처리하는 큐이다.  
  
## 동기(sync), 비동기(Async)  
  
**sync?**  
동기는 말 그대로 동시에 일어난다는 뜻이다.  
요청과 그 결과가 동시에 일어난다는 약속이다.  
바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야한다.  
요청과 결과가 한 자리에서 동시에 일어남  
A노드와 B노드 사이의 작업 처리 단위를 동시에 맞추겠다.  
  
​ex)  
A의 계좌는 10,000원을 뺄 생각을 하고 있다.  
A의 계좌가 B의 계좌에 10,000원을 송금한다.  
B의 계좌는 10,000원을 받았다는 걸 인지하고, A의 계좌에 10,000원을 받았다고 전송한다.  
A, B 계좌 각 각 차감과 증가가 동시에 발생했다.  
1 ~ 3 과정을 확인한 후 같은 일을 동시에 진행하였다.  
4 과정(계좌이체) 작업은 동기방식으로 처리해야 A에서 보냈는데 B에서 못받는 상황이 없다.  
​  
**Async?**  
비동기는 동시에 일어나지 않는다를 의미한다.  
요청과 결과가 동시에 일어나지 않을거라는 약속이다.  
요청한그자리에서 결과가 주어지지 않음  
노드 사이의 작업 처리 단위를 동시에 맞추지 않아도 된다.  
  
ex)  
학생은 시험 문제를 푼다.  
시험 문제를 모두 푼 학생은 교수한테 전송한다.  
교수는 학생의 시험지를 채점한다.  
채점이 다 된 시험지를 학생에게 전송한다.  
학생은 교수가 전송한 시험지를 받아 결과를 확인한다.  
학생과 교수는 시험지라는 연결고리가 있지만 시험지에 행하는 행위(목적)은 서로 다르기에 둘의 작업 처리 시간은 일치하지 않고, 일치하지 않아도 된다.  
​  
**동기와 비동기의 상황별 장단점**  
동기방식은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점이 있고,  
비동기방식은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점이 있다.  
  
## Grand Central Dispatch  
  
**GCD?**  
Apple에서 만든 멀티코어 환경에서 어플리케이션을 개발할 때 도움을 주는 라이브러리이다.  
task에 작업을 대기열에 주어 순서대로 실행하거나, 작업을 동시에 실행 시키는등 많은 작업을 할 수 있다.  
  
**1. Main Queue**  
Serial Queue이다.  
Main Thread에서 동작하며 보통 UI작업을 수행한다.  
  
**2. Global Queue**  
Concurrent Queue이다.  
Qos에 따른 6가지 종류로 나뉜다. (시스템이 우선 순위에 따라 더 많은 스레드를 배치하고 배터리를 더집중해서 사용하도록 함.)  
  
**서비스 품질 QoS (Quality of Service)**  
``` swift
// 유저와 직접 인터렉티브 : UI관련 (즉시)
DispatchQueue.global(qos: .userInteractive)

// 반드시 필요, 비동기 처리 : 앱 내에서 첨부파일을 열기, 내부 데이터베이스 조회 등 (몇초)
DispatchQueue.global(qos: .userInitiated)    

// 일반적인 작업
DispatchQueue.global()    

// ProgressIndicator와 함께 길게 사용되는 작업 : 지속적인 데이터 feed, Networking (몇초~몇분)
DispatchQueue.global(qos: .utility)    

// 사용자가 직접적으로 인지하지 않는 부분 : 데이터베이스 유지 등 (속도보다는 에너지 효율성 중시)
DispatchQueue.global(qos: .background)

// 사용하지 않음 legacy API
DispatchQueue.global(qos: .unspecified)
```
  
**3. private Queue**  
default로는 Serial Queue이며, Concurrent Queue로 설정도 가능하다.  
Qos도 설정이 가능하며, 굳이 설정을 해주지 않아도 OS가 알아서 Qos를 추론한다.  
  
## GCD사용 시 주의사항  
  
**1.한 가지의 작업은 하나의 큐에서만 해야한다.**  
ex) 만약 UI작업을 메인큐에서 했다면 다른 큐에서 하면 안된다.  
   
**2.메인 큐에서 다른 큐로 보낼 때에는 동기적으로 보내면 안된다. (비 동기적으로 해야함.)**  
ex) 왜냐하면 메인 큐에서 작업을 동기적으로 보내면 다른 큐가 그 일을 마칠 때까지 메인 큐가 기다리게된다.  
더 자세히 설명하면 메인 큐가  
작업1을 수행중이라고 하자. 이후 작업 2도 있다.  
작업 1은 UI구성 및 네트워킹해서 이미지를 띄우는 작업을 한다고 가정하자.  
작업 1을 메인큐가 UI구성을 위해 하다가,  
네트워킹 이미지띄우는 작업을 위해 동기적으로 다른 큐로 보내면, 그 다른 큐가 그 일을 마칠 때까지 메인 큐는 작업2를 수행할 수 없다. 작업 1이 다른 큐가 일을 마칠 때까지 block상태가 된 것이다.  
​  
**3.현재의 큐에서 현재의 큐로 동기적으로 보내면 안된다. (데드락 발생) ❗️중요❗️**  
ex) 예시를 들자면 디폴트 큐에서 작업 1을 수행하고있다.  
근데 동기적으로 디폴트 큐에 또 작업1을 보내면 디폴트 큐는 blcok상태가 되었다. 그러면 작업1을 수행할 수 있을까? 교착상태가 발생한다.  
​  
**4.내가 만약 뷰컨트롤러를 참조하는 비동기적인 코드를 작성할 때 {} 코드블럭내에 클로저로 작성하는데 클로저는 값을 캡쳐한다.**  
만약 weak self 코드를 작성해주지 않았다면 기본값인 strong로 레퍼런스 카운트가 올라가기 때문에 뷰 컨트롤러에서 필요한 거를 다해서 ARC에서 레퍼런스카운트를 1감소 시켰는데 위에 작성한 클로저문에서 캡쳐로 Strong로 되어서 ARC는 여전히 0이 아니다. 그래서 레퍼런스 사이클이 발생.  
그리고 weak로 선언하면 내부에 다른 클로저도 weak도 선언됨.  
​  
## 그 외에 내용들  
  
**(비동기 작업에서) 컴플리션핸들러의 존재 이유**  
비동기 작업을 시키고 나서 작업에 해당하는 값을 바로 사용하면 안된다.  
만약 작업이 아직 종료되지 않았는데  
해당 값에 접근하면 잘못된 값을 사용할 확률이 높다.  
그래서 해당 비동기 작업이 끝났다는 것을 정확히 알려주는 시점이 컴플리션 핸들러이다.  
비동기 함수와 관련된 작업들을 모두 컴플리션 핸들러를 갖는다.  
​  
**디스패치 그룹**  
디스패치 그룹을 사용하는 이유는  
각 테스크들을 그룹화 시켜서  
그 그룹의 테스크가 모두 끝났다면  
해야할 일이 있을 수도 있다.  
그럴 때 그룹을 사용한다.  
​  
**동기적인 기다림**  
어떤 이유로 그룹의 완료 알림이 비동기적으로 응답할 수 없는 경우에는 대신 디스패치 그룹에서 wait메서드를 사용한다. 모든 작업이 완료 될 때까지 현재 대기열을 차단하는 동기적 방법이다.  
작업이 완료 될 때까지 얼마나 오래기다릴지 기다리는 시간을 지정하는 선택적(optional)파라미터가 필요하다. (지정하지 않을 시 무제한 대기)  
주의 : 메인 큐에서 wait를 사용하면 메인 큐가 block되기에 메인 큐가 아닌 다른 큐에서는 wait사용 가능  
​  
그룹을 사용하는 이유가 특정 그룹의 테스크가 모두 끝났다면 해야할 일이 존재할 때 그룹을 사용한다고 했다.  
예시를 들어보겠다.  
만약 그룹1과 작업1이 있다고하자. (작업1은 그룹1에 포함됨)  
그룹 1이 끝나면 "그룹1 작업 완료"라고 출력되고,  
작업 1은 "작업1 작업 시작"이라는 출력과 비동기적으로 작업 1이 작업하는 큐와 다른 큐에서 작업하는 클로저 문이 있다고 가정하자.  
만약 위 상황을 예상해보자면  
작업 1이 "작업1 작업시작"이라는 출력문을 내고  
이후 클로저 문을 다른 큐에 보내고 작업1은 작업을 끝낸다.  
그러면 그룹1에 있는 모든 작업이 끝났기 때문에 "그룹1 작업 완료"를 출력할 것이다.  
하지만 작업 1이 수행해야했던 클로저 문은 다른 큐에서 실행되고 있다. 사실 상 작업1이 맡아서 하던 작업이 끝나지 않은 셈이다.  
그러면 그룹1이 작업이 모두 끝나고 하기로 했던 일이 있었는데, 작업 1은 다른 큐에게 작업을 넘기고 끝났다고 선언한 것이다. 상황에 따라 다르겠지만 이러면 크나큰 오류를 초래할 수 있다.  
그러면 디스패치 그룹을 사용할 때 테스크가 비동기적인 작업을 포함하고 있을 때는 어떻게 처리해야할까?  
group1.enter()  
group2.leave() 이런식으로 입장 or 퇴장했다는 것을 알려주면 된다.  
​  
**비동기 디스패치 그룹 함수 만들기**  
(그룹을 파라미터로 비동기 디스패치 그룹 함수화)  
ex) 런치 스크린에서 여러 애니메이션이 있다고 가정하면 비동기적으로 실행되고 끝나고 홈 화면으로 넘어가야함.  
그럴 때 그룹함수 만들어서 재사용성 좋게 짜면 됨.  
​  
**디스패치 워크 아이템**  
작업을 클래스화한 객체이다.  
작업을 미리 정의해놓고 사용하는 큐에 제출하기 위한 객체  
빈약한 취소기능을 내장  
cancel()메서드  
작업이 아직 시작 안했다면(아직 큐에 있다면) 작업이 제거된다.  
작업이 실행 중인 경우 isCancelled속성이 true로 설정됨. (직접 작업을 멈추는 것은 아님)  
빈약한 순서기능을 내장  
notify(queue: 실행할 큐, execute:디스패치아이템) 메서드가 존재한다.(직접적으로 실행한 다음에 실행할 작업 지정)  
​  
**디스패치 세마포어**  
공유리소스에 접근 가능한 작업 수를 제한할 때  
보니까 카운트 세마포어 방식이다.  
세마포어 선언은  
DispatchSemaphore(value: 4) 이런식으로 한다.  
